注意点
1. App.js可以看作是应用的主要入口点之一，其为常见的命名约定，通常包含了应用的根组件，
这个根组件会渲染应用中其他的主要组件；
2. components文件夹下可以写很多的组件，并可以通过一个index.js来进行统一暴露出去即可；
3. 一般组件较多的时候，通过懒加载来进行,但是对于Suspense悬停的组件最好是立刻暴露
4. 对于react18而言，很多内容都已经更新了，比如进行渲染的时候使用ReactDOM.createRoot()
5. 生命周期钩子componentDidMount；
    - 在组件被挂载到DOM之后立即调用，
    - 也就是说：在第一次渲染之后调用
    - 通常用于执行诸如 数据获取、订阅、手动操作DOM等副作用
6. 类式组件里面书写对象，
7. 样式书写完毕了以后直接引入以后就可以使用了，因为对外定义了className（会自动识别出样式）
8. 虽然利用props可以逐层传递，但是如果层数太多怎么办？一个个写上去太low了; （但是对于父子组件来说props依然是最简单的东西）
9. 很多重复利用的东西可以通过解构赋值的形式拿出来，后面再重复利用
10. 在react中，花括号{}的用途
    - 插值（表达式），可以在组件的JSX代码中插入变量、调用函数、简单的运算
    - 属性值，用于组件属性中，以便将JS表达式作为属性值传递
    - 内联样式，花括号用于定义内联样式，对象的属性必须是JS表达式，因此需要使用双重花括号（花括号用于定义内联样式）
    - 条件渲染（类似于表达式，即三元运算符）
11. 函数式组件是没有this的，这一点很关键
12. span标签与普通的HTML中使用方式相同，其是一个内联元素，主要用于包裹和分组小段的文本或其他内联元素。**通过JSX语法，更易于结合JS逻辑、条件渲染和组件化结构**。
13. 父组件的状态只要一更新就会重新帮你调用render
14. 内容大多都是在render中书写，return返回的语句是jsx语法
15. 真正的标签体内容是通过this.props.children来获取
```
<A>hello!<A/>
在子组件中通过{ this.props.children }来获取内容
```
16. 在 React 中，this.props.children 是一个特殊的属性，用来表示组件的子节点（children）。这些子节点是通过 JSX 语法在父组件中传递的内容。
17. webpack 可以帮忙检测兼容性和语法检查等，还可以打包，让网页上方的react图标
- 我们平时训练主要是通过 npm run start 开启了一台本地服务器
- 很多内容都没有弄好
- 打包流程
    - 1. 停止服务器
    - 2. npm run build（生成一个static文件，里面很复杂）
    - 3. 静态文件需要部署到服务器上效果才会更好
        - express Node
        - 第三方库，如serve（全局安装这个库）
        - 安装全局的第三方库命令：npm i serve -g
            - 再通过serve build来操作运行即可
    - 如何让一个应用打包上线去运行，这一点很关键
- 如果没有入口index.jsx 需要具体引入相应的jsx文件，要不然找不到会报错
18. 生命周期钩子；
    - static getDerivedStateFromProps(props, state)
        - 在调用'render'方法之间调用，并且在初始挂载及后续更新时都会被调用。
        - 它应返回一个对象来更新state，如果不需要更新，则返回null

19. 组件错误处理
- 错误处理（Error Handling）
    - 当组件渲染过程中、生命周期方法或子组件的构造函数中抛出错误时调用：
- static getDerivedStateFromError(error)
    - 用于渲染备用UI。
    - 在抛出错误后调用，返回一个对象来更新state。
- componentDidCatch(error, info)
    - 捕获错误，并记录错误信息。